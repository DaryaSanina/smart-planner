from fastapi import FastAPI
from fastapi.responses import JSONResponse
import uvicorn
from mangum import Mangum
import mysql.connector
from dotenv import load_dotenv
import os
from pydantic import BaseModel
import datetime
from typing import Optional
import boto3
import json

app = FastAPI()
handler = Mangum(app)
lambda_client = boto3.client('lambda')

# Connect to the database
load_dotenv()
mysql_password = os.getenv("MYSQL_PASSWORD")
mysql_host = os.getenv("MYSQL_HOST")


# A POST request JSON object that represents a user that needs to be created
class User(BaseModel):
    username: str
    password_hash: str
    password_salt: str


# A POST request JSON object that represents a task that needs to be created
class Task(BaseModel):
    name: str
    description: Optional[str] = None

    # In a POST request, the following three attributes should be strings
    # of the following format: "YYYY-MM-DD[T]HH:MM:SS"
    deadline: Optional[datetime.datetime] = None
    start: Optional[datetime.datetime] = None
    end: Optional[datetime.datetime] = None

    importance: int
    user_id: int
    google_calendar_event_id: Optional[str] = None


# A PUT request JSON object that represents a task that needs to be edited
class ExistingTask(BaseModel):
    task_id: int
    name: Optional[str] = None
    description: Optional[str] = None

    # In a POST request, the following three attributes should be strings
    # of the following format: "YYYY-MM-DD[T]HH:MM:SS"
    deadline: Optional[datetime.datetime] = None
    start: Optional[datetime.datetime] = None
    end: Optional[datetime.datetime] = None

    importance: Optional[int] = None
    google_calendar_event_id: Optional[str] = None


# A POST request JSON object that represents a tag that needs to be created
class Tag(BaseModel):
    name: str
    user_id: int


# A POST request JSON object that stores the ID of the task and the ID of the
# tag that need to be connected (the tag needs to be added to the task)
class TaskToTagRelationship(BaseModel):
    task_id: int
    tag_id: int


# A POST request JSON object that represents a task reminder that needs to be
# created
class Reminder(BaseModel):
    task_id: int

    # 1 - 10 minutes before,
    # 2 - 1 hour before,
    # 3 - 1 day before,
    # 4 - 1 week before
    reminder_type: int


# A POST request JSON object that represents a message that needs to be added
# to the database
class Message(BaseModel):
    content: str
    role: int  # 1 - user, 2 - assistant, 3 - tool

    # In a POST request, this should be a string of the following format:
    # "YYYY-MM-DD[T]HH:MM:SS"
    timestamp: datetime.datetime

    user_id: int


# A GET request JSON object that represents an SQL SELECT query generated by
# the chatbot to get relevant information about the user's tasks
class ChatbotQuery(BaseModel):
    sql_query : str
    user_id: int


def check_google_id_token(google_id_token: str) -> str:
    """
    Checks whether the provided Google ID token is valid and returns the user's
    Google account ID

    Parameters
    ----------
    google_id_token : str

    Returns
    -------
    google_id : str
    """
    url_parameters = {
        "queryStringParameters": {
            "google_id_token": google_id_token,
        }
    }
    response = lambda_client.invoke(
        FunctionName="arn:aws:lambda:eu-west-2:639191934765:function:"
            "smart_planner_google_token_id_verification",
        InvocationType='RequestResponse',
        Payload=json.dumps(url_parameters)
    )
    
    # Read and process the response
    response_payload = json.loads(response['Payload'].read().decode('utf-8'))
    return response_payload["userID"]


@app.get('/get_user')
def get_user(google_id_token="", username=""):
    """
    Performs an SQL SELECT query on the Users table of the database and returns
    information about the user (ID, username and password hash) based on their
    username or Google ID token. Username is only used when Google ID token is
    not provided.

    Parameters
    ----------
    google_id_token : str
        A Google ID token of the user to get information about
    username : str
        The username of the user to get information about
    
    Returns
    -------
    JSONResponse
        - {"error": "Invalid Google ID token"}, status_code=400
        - {"error": "Neither username nor Google ID token were provided."},
          status_code=400
        - {"data": [[ID, username, password hash]]} if the user has been found
        - {"data": []} if the user has not been found
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Get user by Google ID token
    if google_id_token != "":
        try:
            google_id = check_google_id_token(google_id_token)
        except ValueError:
            return JSONResponse(
                {"error": "Invalid Google ID token"},
                status_code=400
            )
        
        cursor.execute(
            "SELECT UserID, Username, PasswordHash, PasswordSalt FROM Users "
                + "WHERE GoogleID = %s",
            (google_id,)
        )
        result = cursor.fetchall()
        return JSONResponse({"data": result})

    # Get user by username
    if username == "":
        return JSONResponse(
            {"error": "Neither username nor Google ID token were provided."},
            status_code=400
        )
    else:
        cursor.execute("SELECT * FROM Users WHERE Username = %s", (username,))
    result = cursor.fetchall()
    db.close()
    return JSONResponse({"data": result})


@app.post('/add_user')
def add_user(user: User):
    """
    Adds the provided user to the database

    Parameters
    ----------
    user : User
        Information about the user that needs to be added to the database
    
    Returns
    -------
    JSONResponse
        - {"error": "The username is not between 3 and 32 characters long"},
          status_code=400
        - {"error": "A user with this username already exists"},
          status_code=400
        - {"error": "Password hash is not 64 characters long"}, status_code=400
        - {"error": "The password salt is empty"}, status_code=400
        - {"error": "Password salt is more than 64 characters long"},
          status_code=400
        - {"id": the new user's ID}, status_code=201
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the username is valid
    if not (3 <= len(user.username) <= 32):
        return JSONResponse(
            {"error": "The username is not between 3 and 32 characters long"},
            status_code=400
        )
    cursor.execute("SELECT * FROM Users WHERE Username = %s", (user.username,))
    if len(cursor.fetchall()) > 0:
        return JSONResponse(
            {"error": "A user with this username already exists"},
            status_code=400
        )

    # Check whether the password hash is valid
    if len(user.password_hash) != 64:
        return JSONResponse(
            {"error": "Password hash is not 64 characters long"},
            status_code=400
        )
    
    # Check whether the password salt is valid
    if len(user.password_salt) == 0:
        return JSONResponse(
            {"error": "The password salt is empty"},
            status_code=400
        )
    
    if len(user.password_salt) > 64:
        return JSONResponse(
            {"error": "Password salt is more than 64 characters long"},
            status_code=400
        )

    # Insert the data
    cursor.execute(
        "INSERT INTO Users VALUES (NULL, %s, %s, %s, NULL)",
        (user.username, user.password_hash, user.password_salt)
    )
    db.commit()
    return JSONResponse({"id": cursor.lastrowid}, status_code=201)


@app.put('/update_username')
def update_username(user_id: int, username: str):
    """
    Updates the username of the user with the provided ID in the database.

    Parameters
    ----------
    user_id : int
        ID of the user whose username needs to be updated
    username : str
        New username
    
    Returns
    -------
    JSONResponse
        - {"error": "The username is not between 3 and 32 characters long"},
          status_code=400
        - {"error": "A user with this username already exists"},
          status_code=400
        - {"id": the user's ID}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the username is valid
    if not (3 <= len(username) <= 32):
        return JSONResponse(
            {"error": "The username is not between 3 and 32 characters long"},
            status_code=400
        )
    cursor.execute("SELECT * FROM Users WHERE Username = %s", (username,))
    if len(cursor.fetchall()) > 0:
        return JSONResponse(
            {"error": "A user with this username already exists"},
            status_code=400
        )

    # Update the data
    cursor.execute(
        "UPDATE Users SET Username = %s WHERE UserID = %s",
        (username, user_id)
    )
    db.commit()
    db.close()
    return JSONResponse({"id": user_id}, status_code=200)


@app.put('/update_password')
def update_password(user_id: int, password_hash: str, password_salt: str):
    """
    Updates the password hash of the user with the provided ID in the database.

    Parameters
    ----------
    user_id : int
        ID of the user whose password hash needs to be updated
    password_hash : str
        New password hash
    password_salt : str
        New password salt
    
    Returns
    -------
    JSONResponse
        - {"error": "The password hash is not 64 characters long"},
          status_code=400
        - {"error": "The password salt is empty"}, status_code=400
        - {"error": "The password salt is more than 64 characters long"},
          status_code=400
        - {"id": the user's ID}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the password hash is valid
    if len(password_hash) != 64:
        return JSONResponse(
            {"error": "The password hash is not 64 characters long"},
            status_code=400
        )

    # Check whether the password salt is valid
    if len(password_salt) == 0:
        return JSONResponse(
            {"error": "The password salt is empty"},
            status_code=400
        )
    
    if len(password_salt) > 64:
        return JSONResponse(
            {"error": "The password salt is more than 64 characters long"},
            status_code=400
        )

    # Update the data
    cursor.execute(
        "UPDATE Users SET PasswordHash = %s, PasswordSalt = %s WHERE UserID = %s",
        (password_hash, password_salt, user_id)
    )
    db.commit()
    db.close()
    return JSONResponse({"id": user_id}, status_code=200)


@app.put('/link_google_account')
def link_google_account(user_id: int, google_id_token: str):
    """
    Updates the Google account ID of the user with the provided ID in the
    database.

    Parameters
    ----------
    user_id : int
        ID of the user whose Google account ID hash needs to be updated
    google_id_token : str
        A token based on which the new Google ID can be determined
    
    Returns
    -------
    JSONResponse
        - {"error": "Invalid Google ID token"}, status_code=400
        - {"id": the user's ID}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the Google ID token is valid
    try:
        google_id = check_google_id_token(google_id_token)
    except ValueError:
        return JSONResponse(
            {"error": "Invalid Google ID token"},
            status_code=400
        )
    
    # Update the data
    cursor.execute(
        "UPDATE Users SET GoogleID = %s WHERE UserID = %s",
        (google_id, user_id)
    )
    db.commit()
    db.close()
    return JSONResponse({"id": user_id}, status_code=200)


@app.delete('/delete_user')
def delete_user(user_id: int):
    """
    Deletes the user with the provided ID from the database.

    Parameters
    ----------
    user_id : int
        ID of the user who needs to be deleted from the database
    
    Returns
    -------
    JSONResponse
        {}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    cursor.execute("DELETE FROM Users WHERE UserID = %s", (user_id,))
    db.commit()
    db.close()
    return JSONResponse({})


@app.get('/get_task')
def get_task(task_id=0, user_id=0):
    """
    Performs an SQL SELECT query on the Tasks table of the database and returns
    information about the task or the tasks with the provided task ID and / or
    user ID.

    Parameters
    ----------
    task_id : int
        The ID of the task to get information about
    user_id : int
        The ID of the user whose tasks the client needs get information about
    
    Returns
    -------
    JSONResponse
        - {"error": "Neither the ID of the task nor the ID of the user were
          provided"}, status_code=400
        - {
            "data": [
                [
                    ID 1, name 1, description 1, deadline 1, start 1, end 1,
                    importance 1, user ID 1, Google Calendar event ID 1
                ],
                [
                    ID 2, name 2, description 2, deadline 2, start 2, end 2,
                    importance 2, user ID 2, Google Calendar event ID 2
                ],
                [
                    ID 3, name 3, description 3, deadline 3, start 3, end 3,
                    importance 3, user ID 3, Google Calendar event ID 3
                ],
                ...
            ]
          }
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    if task_id == 0 and user_id == 0:
        return JSONResponse(
            {
                "error": "Neither the ID of the task nor the ID of the user "
                    + "were provided"
            },
            status_code=400
        )
    elif user_id == 0:
        cursor.execute("SELECT * FROM Tasks WHERE TaskID = %s", (task_id,))
    elif task_id == 0:
        cursor.execute("SELECT * FROM Tasks WHERE UserID = %s", (user_id,))
    else:
        cursor.execute(
            "SELECT * FROM Tasks WHERE UserID = %s AND TaskID = %s",
            (user_id, task_id)
        )
    result = cursor.fetchall()
    result = list(result)
    for i in range(len(result)):
        result[i] = list(result[i])
        for j in range(len(result[i])):
            if type(result[i][j]) == datetime.datetime:
                result[i][j] = result[i][j].strftime("%Y-%m-%dT%H:%M:%S")
    db.close()
    return JSONResponse({"data": result})


@app.post('/add_task')
def add_task(task: Task):
    """
    Adds the provided task to the database

    Parameters
    ----------
    task : Task
        Information about the task that needs to be added to the database
    
    Returns
    -------
    JSONResponse
        - {"error": "Task name is not between 3 and 256 characters long"},
          status_code=400
        - {"error": "Importance is not between 0 and 10"}, status_code=400
        - {"error": "The task should either have a deadline or a start datetime
          and an end datetime"}, status_code=400
        - {"error": "The user with this ID does not exist"}, status_code=400
        - {"id": the new task's ID}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the task name is valid
    if not (3 <= len(task.name) <= 256):
        return JSONResponse(
            {"error": "Task name is not between 3 and 256 characters long"},
            status_code=400
        )

    # Check whether the importance is valid
    if not (0 <= task.importance <= 10):
        return JSONResponse(
            {"error": "Importance is not between 0 and 10"},
            status_code=400
        )

    # Check whether there is either a deadline or a start datetime and an end
    # datetime
    if not(
            (task.deadline is not None
             and task.start is None
             and task.end is None)
        or (task.deadline is None
            and task.start is not None
            and task.end is not None)):
        return JSONResponse(
            {
                "error": "The task should either have a deadline or a start "
                    + "datetime and an end datetime"
            },
            status_code=400
        )

    # Check whether the user with this ID exists
    cursor.execute("SELECT * FROM Users WHERE UserID = %s", (task.user_id,))
    if len(cursor.fetchall()) == 0:
        return JSONResponse(
            {"error": "The user with this ID does not exist"},
            status_code=400
        )

    # Insert the data
    if task.deadline:
        deadline = task.deadline.strftime("%Y-%m-%d %H:%M:%S")
        cursor.execute(
            "INSERT INTO Tasks VALUES "
                + "(NULL, %s, %s, %s, NULL, NULL, %s, %s, %s)",
            (
                task.name,
                task.description,
                deadline,
                task.importance,
                task.user_id,
                task.google_calendar_event_id
            )
        )
    elif task.start and task.end:
        start = task.start.strftime("%Y-%m-%d %H:%M:%S")
        end = task.end.strftime("%Y-%m-%d %H:%M:%S")
        cursor.execute(
            "INSERT INTO Tasks VALUES (NULL, %s, %s, NULL, %s, %s, %s, %s, %s)",
            (
                task.name,
                task.description,
                start,
                end,
                task.importance,
                task.user_id,
                task.google_calendar_event_id
            )
        )
    db.commit()
    return JSONResponse({"id": cursor.lastrowid}, status_code=201)


@app.put('/update_task')
def update_task(task: ExistingTask):
    """
    Updates the details of the provided task in the database.

    Parameters
    ----------
    task : ExistingTask
        The details of the task that needs to be updated in the database
        (including its ID)
    
    Returns
    -------
    JSONResponse
        - {"error": "The task with this ID does not exist"}, status_code=400
        - {"error": "Task name is not between 3 and 50 characters long"},
          status_code=400
        - {"error": "Importance is not between 0 and 10"}, status_code=400
        - {"error": "The task should either have a deadline or a start datetime
          and an end datetime"}, status_code=400
        - {}, status_code=201
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the task with this ID exists
    cursor.execute("SELECT * FROM Tasks WHERE TaskID = %s", (task.task_id,))
    if len(cursor.fetchall()) == 0:
        return JSONResponse(
            {"error": "The task with this ID does not exist"},
            status_code=400
        )

    updates = []

    if task.name is not None:
        if not (3 <= len(task.name) <= 256):
            return JSONResponse(
                {"error": "Task name is not between 3 and 256 characters long"},
                status_code=400
            )
        updates.append(f"Name = '{task.name}'")

    if task.description is not None:
        updates.append(f"Description = '{task.description}'")

    if task.importance is not None:
        if not (0 <= task.importance <= 10):
            return JSONResponse(
                {"error": "Importance is not between 0 and 10"},
                status_code=400
            )
        updates.append(f"Importance = {task.importance}")

    if task.deadline:
        if task.start or task.end:
            return JSONResponse(
                {
                    "error": "The task should either have a deadline or a "
                        + "start datetime and an end datetime"
                },
                status_code=400
            )
        updates.append(
            f"Deadline = '{task.deadline}, "
                + "Start = NULL, End = NULL'"
        )

    if task.start or task.end:
        if task.deadline or not task.start or not task.end:
            return JSONResponse(
                {
                    "error": "The task should either have a deadline or a "
                        + "start datetime and an end datetime"
                },
                status_code=400
            )
        updates.append(
            f"Deadline = NULL, Start = '{task.start}', End = '{task.end}'"
        )
    
    if task.google_calendar_event_id is not None:
        updates.append(
            f"GoogleCalendarEventID = '{task.google_calendar_event_id}'"
        )

    if len(updates) > 0:
        statement = f"UPDATE Tasks SET " + ", ".join(updates) \
            + f" WHERE TaskID = {task.task_id}"
        cursor.execute(statement)
        db.commit()
    db.close()
    return JSONResponse({}, status_code=201)


@app.delete('/delete_task')
def delete_task(task_id: int):
    """
    Deletes the task with the provided ID from the database.

    Parameters
    ----------
    task_id : int
        ID of the task that needs to be deleted
    
    Returns
    -------
    JSONResponse
        {}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Delete all the tag connections for this task
    cursor.execute("DELETE FROM TasksToTags WHERE TaskID = %s", (task_id,))

    # Delete all the reminders for this task
    cursor.execute("DELETE FROM Reminders WHERE TaskID = %s", (task_id,))

    # Delete the task
    cursor.execute("DELETE FROM Tasks WHERE TaskID = %s", (task_id,))

    db.commit()
    db.close()
    return JSONResponse({})


@app.get('/get_tags')
def get_tags(user_id=0, task_id=0):
    """
    Performs an SQL SELECT query on the Tags table of the database and returns
    all tags created by the user with the provided ID or all tags of the task
    with the provided ID, if user ID is not provided.

    Parameters
    ----------
    user_id : int
        ID of the user whose tags need to be provided
    task_id : int
        ID of the task for which tags need to be provided
    
    Returns
    -------
    JSONResponse
        - {"error": "Neither user ID nor task ID have been provided."},
          status_code=400
        - {
            "data": [
                [tag ID 1, tag name 1, user ID 1],
                [tag ID 2, tag name 2, user ID 2],
                [tag ID 3, tag name 3, user ID 3],
                ...
            ]
          }
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # No parameters have been provided
    if user_id == 0 and task_id == 0:
        return JSONResponse(
            {"error": "Neither user ID nor task ID have been provided."},
            status_code=400
        )

    # Get tags by user ID
    elif task_id == 0:
        cursor.execute("SELECT * FROM Tags WHERE UserID = %s", (user_id,))
    
    # Get tags by task ID
    else:
        cursor.execute(
            "SELECT * FROM Tags JOIN TasksToTags "
                + "ON (Tags.TagID = TasksToTags.TagID) WHERE TaskID = %s",
            (task_id,)
        )
    result = cursor.fetchall()
    db.close()
    return JSONResponse({"data": result})


@app.post('/add_tag')
def add_tag(tag: Tag):
    """
    Adds the provided tag to the database.

    Parameters
    ----------
    tag : Tag
        Information about the tag that needs to be added to the database
    
    Returns
    -------
    JSONResponse
        - {"error": "Tag name is not between 3 and 256 characters long"},
          status_code=400
        - {"error": "The user with this ID does not exist"}, status_code=400
        - {"id": the new tag's ID}, status_code=201
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the tag name is valid
    if not (3 <= len(tag.name) <= 256):
        return JSONResponse(
            {"error": "Tag name is not between 3 and 256 characters long"},
            status_code=400
        )

    # Check whether the user with this ID exists
    cursor.execute("SELECT * FROM Users WHERE UserID = %s", (tag.user_id,))
    if len(cursor.fetchall()) == 0:
        return JSONResponse(
            {"error": "The user with this ID does not exist"},
            status_code=400
        )

    # Insert the data
    cursor.execute(
        "INSERT INTO Tags VALUES (NULL, %s, %s)",
        (tag.name, tag.user_id)
    )
    db.commit()
    return JSONResponse({"id": cursor.lastrowid}, status_code=201)


@app.post('/add_task_to_tag_relationship')
def add_task_to_tag_relationship(
    task_to_tag_relationship: TaskToTagRelationship
):
    """
    Adds a task to tag relationship to the database when a tag needs to be added
    to a task.

    Parameters
    ----------
    task_to_tag_relationship : TaskToTagRelationship
        Information about the task to tag relationship that needs to be added - 
        task ID and tag ID
    
    Returns
    -------
    JSONResponse
        - {"error": "The task with this ID does not exist"}, status_code=400
        - {"error": "The tag with this ID does not exist"}, status_code=400
        - {"id": ID of the new task to tag relationship}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the task with this ID exists
    cursor.execute(
        "SELECT * FROM Tasks WHERE TaskID = %s",
        (task_to_tag_relationship.task_id,)
    )
    if len(cursor.fetchall()) == 0:
        return JSONResponse(
            {"error": "The task with this ID does not exist"},
            status_code=400
        )

    # Check whether the tag with this ID exists
    cursor.execute(
        "SELECT * FROM Tags WHERE TagID = %s",
        (task_to_tag_relationship.tag_id,)
    )
    if len(cursor.fetchall()) == 0:
        return JSONResponse(
            {"error": "The tag with this ID does not exist"},
            status_code=400
        )

    # Insert the data
    cursor.execute(
        "INSERT INTO TasksToTags VALUES (NULL, %s, %s)",
        (task_to_tag_relationship.task_id, task_to_tag_relationship.tag_id)
    )
    db.commit()
    return JSONResponse({"id": cursor.lastrowid}, status_code=201)


@app.delete('/delete_task_to_tag_relationship')
def delete_task_to_tag_relationship(task_id: int, tag_id: int):
    """
    Deletes the task to tag relationship with the specified task ID and tag ID.

    Parameters
    ----------
    task_id : int
        ID of the task for which a task to tag relationship needs to be deleted
    tag_id : int
        ID of the tag for which a task to tag relationship needs to be deleted
    
    Returns
    -------
    JSONResponse
        {}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    cursor.execute(
        "DELETE FROM TasksToTags WHERE TaskID = %s AND TagID = %s",
        (task_id, tag_id)
    )
    db.commit()
    db.close()
    return JSONResponse({})


@app.get('/get_reminders')
def get_reminders(task_id: int):
    """
    Performs an SQL SELECT query on the Reminders table of the database and
    returns the reminders of the task with the provided ID.

    Parameters
    ----------
    task_id : int
        ID of the task for which reminders need to be provided
    
    Returns
    -------
    JSONResponse
        {
            "data": [
                [reminder ID 1, task ID 1, reminder type 1],
                [reminder ID 2, task ID 2, reminder type 2],
                [reminder ID 3, task ID 3, reminder type 3],
                ...
            ]
        }
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    cursor.execute("SELECT * FROM Reminders WHERE TaskID = %s", (task_id,))
    result = cursor.fetchall()
    db.close()
    return JSONResponse({"data": result})


@app.post('/add_reminder')
def add_reminder(reminder: Reminder):
    """
    Adds a reminder to the database.

    Parameters
    ----------
    reminder : Reminder
        Information about the reminder that needs to be added to the database
    
    Returns
    -------
    JSONResponse
        - {"error": "The task with this ID does not exist"}, status_code=400
        - 
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the task with this ID exists
    cursor.execute(
        "SELECT * FROM Tasks WHERE TaskID = %s",
        (reminder.task_id,)
    )
    if len(cursor.fetchall()) == 0:
        return JSONResponse(
            {"error": "The task with this ID does not exist"},
            status_code=400
        )

    # Check whether the reminder type is valid (between 1 and 4)
    if not (1 <= reminder.reminder_type <= 4):
        return JSONResponse(
            {"error": "The reminder type should be an integer between 1 and 4"},
            status_code=400
        )

    # Insert the data
    cursor.execute(
        "INSERT INTO Reminders VALUES (NULL, %s, %s)",
        (reminder.task_id, reminder.reminder_type)
    )
    db.commit()
    return JSONResponse({"id": cursor.lastrowid}, status_code=201)


@app.delete('/delete_reminder')
def delete_reminder(reminder: Reminder):
    """
    Deletes the specified reminder from the database.

    Parameters
    ----------
    reminder : Reminder
        The reminder that should be deleted
    
    Returns
    -------
    JSONResponse
        - {"error": "The specified reminder does not exist"}, status_code=400
        - {"id": the deleted reminder's ID}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the reminder exists
    cursor.execute(
        "SELECT * FROM Reminders WHERE TaskID = %s AND ReminderType = %s",
        (reminder.task_id, reminder.reminder_type)
    )
    result = cursor.fetchall()
    if len(result) == 0:
        return JSONResponse(
            {"error": "The specified reminder does not exist"},
            status_code=400
        )
    reminder_id = result[0][0]

    # Delete the reminder
    cursor.execute(
        "DELETE FROM Reminders WHERE TaskID = %s AND ReminderType = %s",
        (reminder.task_id, reminder.reminder_type)
    )
    db.commit()
    db.close()
    return JSONResponse({"id": reminder_id})


@app.get('/get_messages')
def get_messages(user_id: int):
    """
    Performs and SQL SELECT request and returns all messages sent by or to
    the user.

    Parameters
    ----------
    user_id : int
        ID of the user for whom messages need to be retrieved
    
    Returns
    -------
    JSONResponse
        {
            "data": [
                [message ID 1, content 1, role 1, timestamp 1, user ID],
                [message ID 2, content 2, role 2, timestamp 2, user ID],
                [message ID 3, content 3, role 3, timestamp 3, user ID],
                ...
            ]
        }
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    cursor.execute("SELECT * FROM Messages WHERE UserID = %s", (user_id,))
    result = cursor.fetchall()
    result = list(result)
    for i in range(len(result)):
        result[i] = list(result[i])
        for j in range(len(result[i])):
            if type(result[i][j]) == datetime.datetime:
                result[i][j] = result[i][j].strftime("%Y-%m-%dT%H:%M:%S")
    return JSONResponse({"data": result})


@app.post('/add_message')
def add_message(message: Message):
    """
    Adds a message to the database.

    Parameters
    ----------
    message : Message
        Information about the message that needs to be added to the database
    
    Returns
    -------
    JSONResponse
        - {"error": "The role should be either 1 (user) or 2 (assistant)"},
          status_code=400
        - {"error": "The user with this ID does not exist"}, status_code=400
        - {}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Check whether the role is 1, 2 or 3
    if not (1 <= message.role <= 3):
        return JSONResponse(
            {
                "error": "The role should be either 1 (user), 2 (assistant) "
                    + "or 3 (tool)"
            },
            status_code=400
        )

    # Check whether the user with this ID exists
    cursor.execute("SELECT * FROM Users WHERE UserID = %s", (message.user_id,))
    if len(cursor.fetchall()) == 0:
        return JSONResponse(
            {"error": "The user with this ID does not exist"},
            status_code=400
        )

    # Insert the data
    timestamp = message.timestamp.strftime("%Y-%m-%d %H:%M:%S")
    cursor.execute(
        "INSERT INTO Messages VALUES (NULL, %s, %s, %s, %s)",
        (
            message.content.replace("'", "''"),
            message.role, timestamp,
            message.user_id
        )
    )

    db.commit()
    db.close()
    return JSONResponse({})


@app.post('/get_data_for_chatbot')
def get_data_for_chatbot(query: ChatbotQuery):
    """
    Performs the provided query. It must be an SQL SELECT query. All returned
    data will only contain information for the user with ID specified in the
    provided JSON ChatbotQuery object.

    Parameters
    ----------
    query : ChatbotQuery
        A pydantic BaseModel-based JSON object with the query and the user's ID.
    
    Returns
    -------
    JSONResponse
        - {"error": "The query is empty"}, status_code=400
        - {"error": "The server can only process SELECT queries"},
          status_code=400
        - {"error": "Invalid SQL query"}, status_code=400
        - {"error": f"The server cannot process queries to the {table_name}
          table. It can only process queries to the following tables: Tasks,
          Tags, TasksToTags and Reminders."}, status_code=400
        - {"data": the data returned by the query}
    """
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    if query.sql_query == "":
        return JSONResponse({"error": "The query is empty"}, status_code=400)

    if query.sql_query.split()[0] != "SELECT":
        return JSONResponse(
            {"error": "The server can only process SELECT queries"},
            status_code=400
        )

    if "FROM" not in query.sql_query.split() \
            or len(query.sql_query.split()) \
                <= query.sql_query.split().index("FROM") + 1:
        return JSONResponse(
            {"error": "Invalid SQL query"},
            status_code=400
        )

    table_name = query.sql_query.split()[
        query.sql_query.split().index("FROM") + 1
    ]
    if table_name not in ["Tasks", "Tags", "TasksToTags", "Reminders"]:
        return JSONResponse(
            {
                "error": f"The server cannot process queries to the "
                    + "{table_name} table. It can only process queries to the "
                    + "following tables: Tasks, Tags, TasksToTags and Reminders."
            },
            status_code=400
        )

    try:
        cursor.execute(query.sql_query)
        data = cursor.fetchall()

        field_names = [field[0] for field in cursor.description]

        data = list(data)
        result = []
        for i in range(len(data)):
            data[i] = list(data[i])  # result[i] is a particular record

            # Replace datetime with a JSON-serialisable string
            for j in range(len(data[i])):
                if type(data[i][j]) == datetime.datetime:
                        data[i][j] = data[i][j].strftime("%Y-%m-%dT%H:%M:%S")

            # Attach field names to the record
            data[i] = dict(zip(field_names, data[i]))

            if "UserID" not in data[i].keys() \
                    or int(data[i]["UserID"]) == query.user_id:
                result.append(data[i])

        return JSONResponse({"data": result})

    except Exception as e:
        return JSONResponse(
            {"error": "Invalid SQL query. Error: " + str(e)},
            status_code=400
        )

if __name__ == "__main__":
    db = mysql.connector.connect(
        host=mysql_host,
        port=3306,
        user="admin",
        password=mysql_password,
        database="smart_planner_database"
    )
    cursor = db.cursor()
    # Create the tables if they don't exist
    # Users table
    cursor.execute("""CREATE TABLE IF NOT EXISTS Users (
                        UserID INT AUTO_INCREMENT NOT NULL,
                        Username VARCHAR(32) NOT NULL,
                        PasswordHash CHAR(64) NOT NULL,
                        PasswordSalt VARCHAR(64) NOT NULL,
                        GoogleID VARCHAR(256),
                        PRIMARY KEY (UserID)
                   )""")
    # Tasks table
    cursor.execute("""CREATE TABLE IF NOT EXISTS Tasks (
                        TaskID INT AUTO_INCREMENT NOT NULL,
                        Name VARCHAR(256) NOT NULL,
                        Description TEXT,
                        Deadline DATETIME,
                        Start DATETIME,
                        End DATETIME,
                        Importance INT NOT NULL,
                        UserID INT NOT NULL,
                        GoogleCalendarEventID VARCHAR(256),
                        PRIMARY KEY (TaskID),
                        FOREIGN KEY (UserID) REFERENCES Users(UserID)
                   )""")
    # Tags table
    cursor.execute("""CREATE TABLE IF NOT EXISTS Tags (
                        TagID INT AUTO_INCREMENT NOT NULL,
                        Name VARCHAR(256) NOT NULL,
                        UserID INT NOT NULL,
                        PRIMARY KEY (TagID),
                        FOREIGN KEY (UserID) REFERENCES Users(UserID)
                   )""")
    # Tasks to tags table
    cursor.execute("""CREATE TABLE IF NOT EXISTS TasksToTags (
                        TaskToTagID INT AUTO_INCREMENT NOT NULL,
                        TaskID INT NOT NULL,
                        TagID INT NOT NULL,
                        PRIMARY KEY (TaskToTagID),
                        FOREIGN KEY (TaskID) REFERENCES Tasks(TaskID),
                        FOREIGN KEY (TagID) REFERENCES Tags(TagID)
                   )""")
    # Reminders table
    cursor.execute("""CREATE TABLE IF NOT EXISTS Reminders (
                        ReminderID INT AUTO_INCREMENT NOT NULL,
                        TaskID INT NOT NULL,
                        ReminderType INT NOT NULL,
                        PRIMARY KEY (ReminderID),
                        FOREIGN KEY (TaskID) REFERENCES Tasks(TaskID)
                   )""")
    # Messages table
    cursor.execute("""CREATE TABLE IF NOT EXISTS Messages (
                        MessageID INT AUTO_INCREMENT NOT NULL,
                        Content TEXT NOT NULL,
                        Role INT NOT NULL,
                        Timestamp DATETIME NOT NULL,
                        UserID INT NOT NULL,
                        PRIMARY KEY (MessageID),
                        FOREIGN KEY (UserID) REFERENCES Users(UserID)
                   )""")
    db.commit()
    db.close()

    # Run the server
    uvicorn.run(app, host="127.0.0.1", port=8000, log_config="log.ini")